<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>偷得浮生半日闲</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/luv135/luv135.github.io/blob/hexo/source/_posts/"/>
  <updated>2019-02-28T14:35:18.128Z</updated>
  <id>https://github.com/luv135/luv135.github.io/blob/hexo/source/_posts/</id>
  
  <author>
    <name>Luowei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>双屏异显</title>
    <link href="https://github.com/luv135/luv135.github.io/blob/hexo/source/_posts/2019/02/28/%E5%8F%8C%E5%B1%8F%E5%BC%82%E6%98%BE/"/>
    <id>https://github.com/luv135/luv135.github.io/blob/hexo/source/_posts/2019/02/28/双屏异显/</id>
    <published>2019-02-28T13:59:29.553Z</published>
    <updated>2019-02-28T14:35:18.128Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="ActivityManagerService"><a href="#ActivityManagerService" class="headerlink" title="ActivityManagerService"></a>ActivityManagerService</h1><blockquote><p>参考<br><a href="http://blog.csdn.net/kc58236582/article/details/52484432" target="_blank" rel="noopener">Android6.0 AMS启动Activity（四） AMS内部一些成员变量</a><br>Android M应用启动流程分析<a href="http://www.jianshu.com/p/7ef2e9e80de4" target="_blank" rel="noopener">http://www.jianshu.com/p/7ef2e9e80de4</a></p></blockquote><h2 id="Activity-启动关键流程"><a href="#Activity-启动关键流程" class="headerlink" title="Activity 启动关键流程"></a>Activity 启动关键流程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">//com.android.server.am.ActivityManagerService</span><br><span class="line">public final WaitResult startActivityAndWait(IApplicationThread caller,...)&#123;</span><br><span class="line">    //所有的 ActivityStacks 都是通过此变量进行操作</span><br><span class="line">    //最终会调用到startActivityLocked</span><br><span class="line">    mStackSupervisor.startActivityMayWait(caller, -1, callin...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ActivityStackSupervisor</span><br><span class="line">final int startActivityLocked(IApplicationThread caller,..)&#123;</span><br><span class="line">    //为当前Activity 创建 ActivityRecord </span><br><span class="line">    ActivityRecord r = new ActivityRecord(mService, c...);</span><br><span class="line">    err = startActivityUncheckedLocked(r, sourceRe...)</span><br><span class="line">&#125;</span><br><span class="line">final int startActivityUncheckedLocked(final ActivityRecord r, Activity...)&#123;</span><br><span class="line">    ActivityStack targetStack;</span><br><span class="line">    //新任务</span><br><span class="line">    if (r.resultTo == null &amp;&amp; inTask == null &amp;&amp; !addingToTask</span><br><span class="line">            &amp;&amp; (launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) != 0) &#123;</span><br><span class="line">        newTask = true;</span><br><span class="line">        //创建应用 ActivityStack</span><br><span class="line">        targetStack = computeStackFocus(r, newTask);</span><br><span class="line">        targetStack.moveToFront(&quot;startingNewTask&quot;);</span><br><span class="line">        if (reuseTask == null) &#123;</span><br><span class="line">            //设置ActivityRecord的TaskRecord</span><br><span class="line">            //createTaskRecord,创建一个新的TaskRecord并加入到ActivityStack</span><br><span class="line">            //此处是直接使用了默认显示屏</span><br><span class="line">            r.setTask(targetStack.createTaskRecord(getNextTaskId(),...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    targetStack.mLastPausedActivity = null;</span><br><span class="line">    targetStack.startActivityLocked(r, newTask, ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final void startActivityLocked(ActivityRecord r, boole...)&#123;</span><br><span class="line">    task = r.task;</span><br><span class="line">    //将rTask添加到mTaskHistory</span><br><span class="line">    insertTaskAtTop(rTask, r);</span><br><span class="line">    task.addActivityToTop(r);</span><br><span class="line">&#125;</span><br><span class="line">//com.android.server.am.ActivityStackSupervisor#realStartActivityLocked</span><br><span class="line">final boolean realStartActivityLocked(ActivityRecord r,..)&#123;</span><br><span class="line">    app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,...);</span><br><span class="line">&#125;</span><br><span class="line">//android.app.ActivityThread.ApplicationThread#scheduleLaunchActivity</span><br><span class="line">public final void scheduleLaunchActivity(Intent intent, IBinder token, int ide..)&#123;</span><br><span class="line">&#125;</span><br><span class="line">private void handleLaunchActivity(ActivityClientRecord r, ..)&#123;</span><br><span class="line">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line">    handleResumeActivity(r.token, false, r.isForward..);</span><br><span class="line">&#125;</span><br><span class="line">private Activity performLaunchActivity(ActivityClientRecord r,</span><br><span class="line">    //创建上下文(display)</span><br><span class="line">    Context appContext = createBaseContextForActivity(r, activity);</span><br><span class="line">    //创建 WindowManager, 用于 handleResumeActivity 中 wm.addView(decor, l);</span><br><span class="line">     activity.attach(appContext, this, getIns...);</span><br><span class="line">&#125;</span><br><span class="line">final void handleResumeActivity(IBinder token,...)&#123;</span><br><span class="line">    ActivityClientRecord r = performResumeActivity(token, clearHide);</span><br><span class="line">        //WindowManager</span><br><span class="line">        wm.addView(decor, l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>备忘</p><ul><li>ApplicationThreadNative 实现IApplicationTread接口,从该接口定义的函数可知,AMS通过它可以和应用程序进行交互.</li><li>ActivityThread通过成员变量mAppThread指向它内部类ApplicationThread, 而ApplicationThread从ApplicationThreadNative派生.</li><li>IApplicationThread 仅仅是AMS和另外一个进程的交互接口.</li><li>ProcessRecord 保存了进程相关信息,如IApplicationThread</li></ul><hr><h2 id="任务栈相关类"><a href="#任务栈相关类" class="headerlink" title="任务栈相关类"></a>任务栈相关类</h2><ul><li>ActivityDisplay<ul><li>ActivityStack<ul><li>TaskRecord</li></ul></li></ul></li></ul><h3 id="ActivityDisplay"><a href="#ActivityDisplay" class="headerlink" title="ActivityDisplay"></a>ActivityDisplay</h3><p>代表一个显示屏<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int mDisplayId; 显示屏ID,由初始化时分配</span><br><span class="line">ArrayList&lt;ActivityStack&gt; mStacks; 显示屏的所有ActivityStack.</span><br></pre></td></tr></table></figure></p><h3 id="ActivityContainer"><a href="#ActivityContainer" class="headerlink" title="ActivityContainer"></a>ActivityContainer</h3><p>对应一个 ActivityStack,其 ActivityStack 变是在此类中创建.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">final int mStackId; //任务栈ID</span><br><span class="line">final ActivityStack mStack; //当前new ActivityStack(this,...)</span><br><span class="line">ActivityDisplay mActivityDisplay; //对应的显示屏</span><br><span class="line">ActivityStack createStackOnDisplay(int stackId, int displayId) &#123;</span><br><span class="line">    //1. 根据显示屏ID查找ActivityDisplay</span><br><span class="line">    ActivityDisplay activityDisplay = mActivityDisplays.get(displayId);</span><br><span class="line">    //2. 创建ActivityContainer,在其中会创建mStack,即ActivityStack</span><br><span class="line">    ActivityContainer activityContainer = new ActivityContainer(stackId);</span><br><span class="line">    //3. mActivityContainers保存ActivityContainer</span><br><span class="line">    mActivityContainers.put(stackId, activityContainer);</span><br><span class="line">    //4.将activityContainer内部初始化工作</span><br><span class="line">    activityContainer.attachToDisplayLocked(activityDisplay);</span><br><span class="line">    return activityContainer.mStack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="ActivityStack"><a href="#ActivityStack" class="headerlink" title="ActivityStack"></a>ActivityStack</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ActivityContainer mActivityContainer;</span><br><span class="line">ArrayList&lt;TaskRecord&gt; mTaskHistory; //所有TaskRecord</span><br><span class="line">ArrayList&lt;ActivityStack&gt; mStacks; //对应ActivityDisplay.mStacks</span><br><span class="line">int mDisplayId; //对应的显示屏ID</span><br><span class="line">int mStackId; //任务栈ID</span><br></pre></td></tr></table></figure><h3 id="TaskRecord"><a href="#TaskRecord" class="headerlink" title="TaskRecord"></a>TaskRecord</h3><p>代表一个应用程序的 Activity 顺序栈<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActivityStack stack; //当前所处的应用任务栈</span><br><span class="line">//当前任务栈中的Activity</span><br><span class="line">ArrayList&lt;ActivityRecord&gt; mActivities</span><br></pre></td></tr></table></figure></p><h3 id="ActivityRecord"><a href="#ActivityRecord" class="headerlink" title="ActivityRecord"></a>ActivityRecord</h3><p>表示一个 Activity<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TaskRecord task; //当前Activity所处的应用任务栈</span><br></pre></td></tr></table></figure></p><h2 id="ActivityStackSupervisor"><a href="#ActivityStackSupervisor" class="headerlink" title="ActivityStackSupervisor"></a>ActivityStackSupervisor</h2><p>应用的所有操作都在此类中进行.</p><h2 id="应用缩略图截图-Recents"><a href="#应用缩略图截图-Recents" class="headerlink" title="应用缩略图截图(Recents)"></a>应用缩略图截图(Recents)</h2><p>用于最近任务中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public final Bitmap screenshotActivities(ActivityRecord who) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="ActivityThread"><a href="#ActivityThread" class="headerlink" title="ActivityThread"></a>ActivityThread</h1><h2 id="将窗口到WMS"><a href="#将窗口到WMS" class="headerlink" title="将窗口到WMS"></a>将窗口到WMS</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void android.app.ActivityThread#handleResumeActivity(IBinder token,...)&#123;</span><br><span class="line">    if (a.mVisibleFromClient) &#123;</span><br><span class="line">        a.mWindowAdded = true;</span><br><span class="line">        wm.addView(decor, l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//Activity#mWindowManager</span><br><span class="line">//android.view.Window</span><br><span class="line">public void setWindowManager(WindowManager wm, IBinder..)&#123;</span><br><span class="line">    mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ViewRootImpl"><a href="#ViewRootImpl" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">android.view.ViewRootImpl#performTraversals()&#123;</span><br><span class="line">    relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);</span><br><span class="line">    performDraw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分屏模式下焦点切换"><a href="#分屏模式下焦点切换" class="headerlink" title="分屏模式下焦点切换"></a>分屏模式下焦点切换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//android.view.InputEventReceiver#dispatchInputEvent</span><br><span class="line">private void dispatchInputEvent(int seq, InputEvent event) &#123;</span><br><span class="line">    mSeqMap.put(event.getSequenceNumber(), seq);</span><br><span class="line">    onInputEvent(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//com.android.server.wm.StackTapPointerEventListener#onPointerEvent</span><br><span class="line">public void onPointerEvent(MotionEvent motionEvent) &#123;</span><br><span class="line">    case MotionEvent.ACTION_UP:</span><br><span class="line">    case MotionEvent.ACTION_POINTER_UP: &#123;</span><br><span class="line">        mService.mH.obtainMessage(H.TAP_OUTSIDE_STACK, x, y,</span><br><span class="line">                mDisplayContent).sendToTarget();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//com.android.server.wm.WindowManagerService.H#handleMessage</span><br><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">        case TAP_OUTSIDE_STACK: &#123;</span><br><span class="line">            stackId = ((DisplayContent)msg.obj).stackIdFromPoint(msg.arg1, msg.arg2);</span><br><span class="line">            mActivityManager.setFocusedStack(stackId);   </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="WindowManagerService-窗口管理"><a href="#WindowManagerService-窗口管理" class="headerlink" title="WindowManagerService 窗口管理"></a>WindowManagerService 窗口管理</h1><blockquote><p>《深入理解Android 卷III》深入理解WindowManagerService<a href="http://blog.csdn.net/innost/article/details/47660193" target="_blank" rel="noopener">http://blog.csdn.net/innost/article/details/47660193</a><br>Android 4.4 双显示屏支持实现思路<a href="http://blog.csdn.net/ljp1205/article/details/53540739" target="_blank" rel="noopener">http://blog.csdn.net/ljp1205/article/details/53540739</a><br>Dialog创建到显示:<a href="http://blog.csdn.net/u011913612/article/details/51723510" target="_blank" rel="noopener">http://blog.csdn.net/u011913612/article/details/51723510</a><br>Android双屏异显的实现<a href="http://blog.csdn.net/u011365633/article/details/55001840" target="_blank" rel="noopener">Android双屏异显的实现</a></p></blockquote><p>窗口的根View<code>DecorView</code><br>输入法相关:public boolean inputMethodClientHasFocus(IInputMethodClient client);</p><h2 id="总体流程图"><a href="#总体流程图" class="headerlink" title="总体流程图"></a>总体流程图</h2><h3 id="WindowToken和WindowState关系"><a href="#WindowToken和WindowState关系" class="headerlink" title="WindowToken和WindowState关系"></a>WindowToken和WindowState关系</h3><p><img src="双屏异显_files/_u5FAE_u4FE1_u622A_u56FE_20170718150155.png" alt="WindowToken和WindowState关系" title="WindowToken和WindowState关系"></p><h3 id="WindowState和WindowToken的从属关系"><a href="#WindowState和WindowToken的从属关系" class="headerlink" title="WindowState和WindowToken的从属关系"></a>WindowState和WindowToken的从属关系</h3><p><img src="双屏异显_files/_u5FAE_u4FE1_u622A_u56FE_20170718143201.png" alt="WindowState和WindowToken的从属关系" title="WindowState和WindowToken的从属关系"></p><p>重要成员变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//策略</span><br><span class="line">final WindowManagerPolicy mPolicy = new PhoneWindowManager();</span><br><span class="line">//令牌</span><br><span class="line">final HashMap&lt;IBinder, WindowToken&gt; mTokenMap = new HashMap&lt;&gt;();</span><br><span class="line">//窗口</span><br><span class="line">final HashMap&lt;IBinder, WindowState&gt; mWindowMap = new HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure></p><blockquote><p>其中4.2.2中:</p><ul><li><code>uiHandler</code>对应<code>UiThread#getHandler</code></li><li><code>wmHandler</code>对应<code>DisplayThread#getHandler</code><br><code>AppWindowToken</code>专门用于<code>Activity</code>保存Token</li></ul></blockquote><h2 id="添加窗口流程"><a href="#添加窗口流程" class="headerlink" title="添加窗口流程:"></a>添加窗口流程:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WindowManagerService-&gt;WindowManagerService:addWindowToken(IBinder token, int type)\n/addAppToken(..., IApplicationToken token,...)</span><br><span class="line">WindowManagerService-&gt;WindowManagerService:addWindow(Session session, IWindow client, int seq,...)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void addWindowToken(IBinder token, int type) &#123;</span><br><span class="line">    wtoken = new WindowToken(this, token, type, true);</span><br><span class="line">    mTokenMap.put(token, wtoken);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void addAppToken(...,IApplicationToken token,...) &#123;</span><br><span class="line">    atoken = new AppWindowToken(this, token, voiceInteraction);</span><br><span class="line">    mTokenMap.put(token.asBinder(), atoken);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int addWindow(Session session, IWindow client, ...) &#123;</span><br><span class="line">    WindowToken token = mTokenMap.get(attrs.token);</span><br><span class="line">    if (token == null) &#123;</span><br><span class="line">        token = new WindowToken(this, attrs.token, -1, false);</span><br><span class="line">        addToken = true;</span><br><span class="line">    &#125; </span><br><span class="line">    WindowState win = new WindowState(this, session, client, token,...);</span><br><span class="line">    //////!!!!</span><br><span class="line">    mTokenMap.put(attrs.token, token);</span><br><span class="line">    win.attach();</span><br><span class="line">    //////!!!</span><br><span class="line">    mWindowMap.put(client.asBinder(), win);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mAppTokens 列表中AppWindowToken顺序和ActivityRecord顺序一致</p><blockquote><p>Task task = mTaskIdToTask.get(taskId);<br>task#mAppTokens</p></blockquote><hr><h2 id="其他函数备忘"><a href="#其他函数备忘" class="headerlink" title="其他函数备忘"></a>其他函数备忘</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//获取当前显示屏的WindowState</span><br><span class="line">WindowManagerService#getTokenWindowsOnDisplay</span><br><span class="line">//添加WindState</span><br><span class="line">addWindowToListInOrderLocked()&#123;</span><br><span class="line">    win.getWindowList().add(pos,win)</span><br><span class="line">    win.mToken.windows.add(pos,win)</span><br><span class="line">    win.mAppToken.allAppWindows.add(win);</span><br><span class="line">&#125;</span><br><span class="line">handleDisplayAdded(msg.arg1)</span><br><span class="line">主屏启动其他Activity,副屏被pause</span><br><span class="line">void activityPausedLocked(IBinder token, boolean timeout)</span><br><span class="line">//log hdmi拔出</span><br><span class="line">176-309/? D/hwcomposer: ###hdmi plug out###</span><br></pre></td></tr></table></figure><hr><h1 id="输入系统"><a href="#输入系统" class="headerlink" title="输入系统"></a>输入系统</h1><p>参考:</p><blockquote><p>6.0 源码 <a href="http://blog.csdn.net/u011913612/article/details/53033356?locationNum=2&amp;fps=1" target="_blank" rel="noopener">http://blog.csdn.net/u011913612/article/details/53033356?locationNum=2&amp;fps=1</a><br>从你触摸屏幕开始分析android触摸事件分发<a href="http://www.jianshu.com/p/8bd40df31d43" target="_blank" rel="noopener">http://www.jianshu.com/p/8bd40df31d43</a></p></blockquote><h2 id="基础知识-INotify-与-Epoll"><a href="#基础知识-INotify-与-Epoll" class="headerlink" title="基础知识:INotify 与 Epoll"></a>基础知识:INotify 与 Epoll</h2><h3 id="INotify"><a href="#INotify" class="headerlink" title="INotify"></a>INotify</h3><p>文件监控,如新建,删除.</p><ol><li><p>创建 Inotify 对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fd = inotify_init();</span><br></pre></td></tr></table></figure></li><li><p>添加监听事件,如新建和删除事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int wd = inotify_add_watch(fd, &quot;dev/input&quot;, IN_CREATE | IN_DELETE);</span><br></pre></td></tr></table></figure></li><li><p>事件读取,当事件发生变化时.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct inotify_event events_buf[BUFF_LEN];</span><br><span class="line">size_t len =  read(fd, events_buf, BUFF_LEN);</span><br></pre></td></tr></table></figure></li></ol><h3 id="Epoll-介绍和使用"><a href="#Epoll-介绍和使用" class="headerlink" title="Epoll 介绍和使用"></a>Epoll 介绍和使用</h3><p>可一次等待监听多个描述符的读写状态<br><code>epoll_wait(...)</code>等待事件的到来.</p><h2 id="总体流程图-1"><a href="#总体流程图-1" class="headerlink" title="总体流程图"></a>总体流程图</h2><h3 id="事件上报流程"><a href="#事件上报流程" class="headerlink" title="事件上报流程"></a>事件上报流程</h3><p><img src="双屏异显_files/112.png" alt="事件上报流程" title="事件上报流程"></p><h3 id="输入系统的总体流程与参与者"><a href="#输入系统的总体流程与参与者" class="headerlink" title="输入系统的总体流程与参与者"></a>输入系统的总体流程与参与者</h3><p><img src="双屏异显_files/QQ_u622A_u56FE20170719090119.png" alt="输入系统的总体流程与参与者" title="输入系统的总体流程与参与者"></p><h3 id="IMS结构体系"><a href="#IMS结构体系" class="headerlink" title="IMS结构体系"></a>IMS结构体系</h3><p><img src="双屏异显_files/11.png" alt="IMS结构体系" title="IMS结构体系"></p><h3 id="IMS成员关系"><a href="#IMS成员关系" class="headerlink" title="IMS成员关系"></a>IMS成员关系</h3><p><img src="双屏异显_files/43.png" alt="IMS成员关系" title="IMS成员关系"></p><h2 id="创建-InputManagerService"><a href="#创建-InputManagerService" class="headerlink" title="创建 InputManagerService"></a>创建 InputManagerService</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//SystemServer.java</span><br><span class="line">private void startOtherServices()&#123;</span><br><span class="line">    //step 1. 创建具体对象</span><br><span class="line">    inputManager = new InputManagerService(context); </span><br><span class="line">    inputManager.setWindowManagerCallbacks(wm.getInputMonitor());</span><br><span class="line">    //step 2. 启动工作线程</span><br><span class="line">    inputManager.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="step-1-创建InputManagerService对象"><a href="#step-1-创建InputManagerService对象" class="headerlink" title="step 1 创建InputManagerService对象"></a>step 1 创建InputManagerService对象</h3><p>对象创建过程:</p><ul><li>创建InputManagerService<ul><li>创建NativeInputManager,其继承了InputReaderPolicyInterface等<ul><li>创建EventHub </li><li>创建InputManager(EventHub,…)<ul><li>创建InputDispatcher 事件分发</li><li>创建InputReader(eventHub,..,InputDispatcher) 事件读取</li></ul></li></ul></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> //SystemServer.java</span><br><span class="line"> private void startOtherServices()&#123;</span><br><span class="line">     inputManager = new InputManagerService(context); </span><br><span class="line"> &#125;</span><br><span class="line">//InputManagerService.java</span><br><span class="line">public InputManagerService(Context context) &#123;</span><br><span class="line">    mPtr = nativeInit(this, mContext,...);</span><br><span class="line">&#125;</span><br><span class="line">//com_android_server_input_InputManagerService.cpp</span><br><span class="line">static jlong nativeInit(JNIEnv* env,...) &#123;</span><br><span class="line">    NativeInputManager* im = new NativeInputManager(contextObj,...);</span><br><span class="line">    return reinterpret_cast&lt;jlong&gt;(im);</span><br><span class="line">&#125;</span><br><span class="line">NativeInputManager::NativeInputManager(jobject contextObj,</span><br><span class="line">        jobject serviceObj, const sp&lt;Looper&gt;&amp; looper) :</span><br><span class="line">        mLooper(looper), mInteractive(true) &#123;</span><br><span class="line">    sp&lt;EventHub&gt; eventHub = new EventHub();</span><br><span class="line">    mInputManager = new InputManager(eventHub, this, this);</span><br><span class="line">&#125;</span><br><span class="line">InputManager::InputManager(eventHub, readerPolicy,dispatcherPolicy) &#123;</span><br><span class="line">    mDispatcher = new InputDispatcher(dispatcherPolicy);</span><br><span class="line">    mReader = new InputReader(eventHub, readerPolicy, mDispatcher);</span><br><span class="line">    initialize();</span><br><span class="line">&#125;</span><br><span class="line">//创建读,分发线程.</span><br><span class="line">void InputManager::initialize() &#123;</span><br><span class="line">    mReaderThread = new InputReaderThread(mReader);</span><br><span class="line">    mDispatcherThread = new InputDispatcherThread(mDispatcher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="step-2-启动线程"><a href="#step-2-启动线程" class="headerlink" title="step 2 启动线程"></a>step 2 启动线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//SystemServer.java</span><br><span class="line">private void startOtherServices()&#123;</span><br><span class="line">    inputManager.start();</span><br><span class="line">&#125;</span><br><span class="line">//InputManagerService.java</span><br><span class="line">public void start() &#123;</span><br><span class="line">    nativeStart(mPtr);</span><br><span class="line">&#125;</span><br><span class="line">//com_android_server_input_InputManagerService.cpp</span><br><span class="line">static void nativeStart(JNIEnv* env, jclass /* clazz */, jlong ptr) &#123;</span><br><span class="line">    NativeInputManager* im = reinterpret_cast&lt;NativeInputManager*&gt;(ptr);</span><br><span class="line">    status_t result = im-&gt;getInputManager()-&gt;start();</span><br><span class="line">&#125;</span><br><span class="line">status_t InputManager::start() &#123;</span><br><span class="line">    status_t result = mDispatcherThread-&gt;run(&quot;InputDispatcher&quot;, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">    result = mReaderThread-&gt;run(&quot;InputReader&quot;, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="EventHub"><a href="#EventHub" class="headerlink" title="EventHub"></a>EventHub</h2><h3 id="创建-EventHub"><a href="#创建-EventHub" class="headerlink" title="创建 EventHub"></a>创建 EventHub</h3><p>INotify 可以监听事件的变化,可以通过read来进行读取事件,但是何时读取,则需要Epolll 来进行协助,Epoll 可监听事件的变化并返回:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//创建INotify对象,在此对象中进行事件的监听.</span><br><span class="line">int mINotifyFd = inotify_init();</span><br><span class="line">int mEpollFd = epoll_create(...);</span><br><span class="line">//然后对INotify 对象进行监视,当INotify对象有事件到来时候,则可以调用INotify中的read来进行事件的读取</span><br><span class="line">int result epoll_ctr(mEpollFd, EPOLL_CTL_ADD, mINotifyFd, ..)</span><br><span class="line">//epoll等待事件到来</span><br><span class="line">epoll_wait(...)</span><br></pre></td></tr></table></figure></p><p>EventHub 构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EventHub::EventHub(void) :</span><br><span class="line">        mBuiltInKeyboardId(NO_BUILT_IN_KEYBOARD), mNextDeviceId(1), mControllerNumbers(),</span><br><span class="line">        mOpeningDevices(0), mClosingDevices(0),</span><br><span class="line">        mNeedToSendFinishedDeviceScan(false),</span><br><span class="line">        mNeedToReopenDevices(false),</span><br><span class="line">        mNeedToScanDevices(true),//其在第一次getEvents()会扫描设备</span><br><span class="line">        mPendingEventCount(0), mPendingEventIndex(0), mPendingINotify(false) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="EventHub-获取输入设备"><a href="#EventHub-获取输入设备" class="headerlink" title="EventHub 获取输入设备"></a>EventHub 获取输入设备</h3><p>在<code>InputManager::start()</code>启动之后,<code>mReaderThread</code>将会执行<code>threadLoop()</code>.<br>第一次执行<code>getEvents()</code>将扫描设备并添加到<code>mDevices</code>,将设备添加事件存到<code>buffer</code>上报给<code>InputReader</code>中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">bool InputReaderThread::threadLoop() &#123;</span><br><span class="line">    mReader-&gt;loopOnce();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InputReader::loopOnce()&#123;</span><br><span class="line">    mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);</span><br><span class="line">&#125;</span><br><span class="line">size_t EventHub::getEvents(int timeoutMillis, RawEvent* buffer, size_t bufferSize) &#123;</span><br><span class="line">    //扫描设备</span><br><span class="line">    scanDevicesLocked();</span><br><span class="line">    //讲扫描的设备作为 DEVICE_ADDED事件上报</span><br><span class="line">    while (mOpeningDevices != NULL) &#123;</span><br><span class="line">        Device* device = mOpeningDevices;</span><br><span class="line">        event-&gt;type = DEVICE_ADDED;</span><br><span class="line">        mNeedToSendFinishedDeviceScan = true;</span><br><span class="line">    &#125;</span><br><span class="line">    //添加扫描完成FINISHED_DEVICE_SCAN事件</span><br><span class="line">    if (mNeedToSendFinishedDeviceScan) &#123;</span><br><span class="line">        mNeedToSendFinishedDeviceScan = false;</span><br><span class="line">        event-&gt;type = FINISHED_DEVICE_SCAN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void EventHub::scanDevicesLocked() &#123;</span><br><span class="line">    status_t res = scanDirLocked(DEVICE_PATH);</span><br><span class="line">&#125;</span><br><span class="line">status_t EventHub::scanDirLocked(const char *dirname)&#123;</span><br><span class="line">    while(..)&#123;</span><br><span class="line">        openDeviceLocked(devname);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">status_t EventHub::openDeviceLocked(const char *devicePath) &#123;</span><br><span class="line">    int32_t deviceId = mNextDeviceId++;</span><br><span class="line">    Device* device = new Device(fd, deviceId, String8(devicePath), identifier);</span><br><span class="line">    //触摸屏设备</span><br><span class="line">    device-&gt;classes |= INPUT_DEVICE_CLASS_TOUCH | INPUT_DEVICE_CLASS_TOUCH_MT;</span><br><span class="line">    addDeviceLocked(device);</span><br><span class="line">&#125;</span><br><span class="line">void EventHub::addDeviceLocked(Device* device) &#123;</span><br><span class="line">    mDevices.add(device-&gt;id, device);</span><br><span class="line">    //新增设备加到mOpeningDevices中,用于DEVICE_ADDED事件上报</span><br><span class="line">    device-&gt;next = mOpeningDevices;</span><br><span class="line">    mOpeningDevices = device;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="InputReader"><a href="#InputReader" class="headerlink" title="InputReader"></a>InputReader</h2><h3 id="创建-InputReader"><a href="#创建-InputReader" class="headerlink" title="创建 InputReader"></a>创建 InputReader</h3><p>其中:<br><code>policy</code>对应<code>NativeInputManager</code>对象<br><code>listener</code>对应<code>InputDispatcher</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputReader::InputReader(const sp&lt;EventHubInterface&gt;&amp; eventHub,</span><br><span class="line">        const sp&lt;InputReaderPolicyInterface&gt;&amp; policy,</span><br><span class="line">        const sp&lt;InputListenerInterface&gt;&amp; listener) :</span><br><span class="line">        mContext(this), mEventHub(eventHub), mPolicy(policy),...&#123;</span><br><span class="line">    mQueuedListener = new QueuedInputListener(listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="InputReader-处理-EventHub-上报的设备"><a href="#InputReader-处理-EventHub-上报的设备" class="headerlink" title="InputReader 处理 EventHub 上报的设备"></a>InputReader 处理 EventHub 上报的设备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">void InputReader::loopOnce() &#123;</span><br><span class="line">    //第一次执行getEvents将会去扫描设备</span><br><span class="line">    size_t count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);</span><br><span class="line">    processEventsLocked(mEventBuffer, count);</span><br><span class="line">    mQueuedListener-&gt;flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InputReader::processEventsLocked(const RawEvent* rawEvents, size_t count) &#123;</span><br><span class="line">    //rawEvents数据:&#123;DEVICE_ADDED,DEVICE_ADDED,..FINISHED_DEVICE_SCAN&#125;</span><br><span class="line">    for (const RawEvent* rawEvent = rawEvents; count;) &#123;</span><br><span class="line">        switch (rawEvent-&gt;type) &#123;</span><br><span class="line">        case EventHubInterface::DEVICE_ADDED:</span><br><span class="line">            //添加设备事件</span><br><span class="line">            addDeviceLocked(rawEvent-&gt;when, rawEvent-&gt;deviceId);</span><br><span class="line">            break;</span><br><span class="line">        case EventHubInterface::FINISHED_DEVICE_SCAN:</span><br><span class="line">            //添加设备事件最后一个事件一定为FINISHED_DEVICE_SCAN</span><br><span class="line">            handleConfigurationChangedLocked(rawEvent-&gt;when);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InputReader::addDeviceLocked(nsecs_t when, int32_t deviceId) &#123;</span><br><span class="line">    ssize_t deviceIndex = mDevices.indexOfKey(deviceId);</span><br><span class="line">    InputDevice* device = createDeviceLocked(deviceId, controllerNumber, identifier, classes);</span><br><span class="line">    //配置设备的InputMapper</span><br><span class="line">    device-&gt;configure(when, &amp;mConfig, 0);</span><br><span class="line">    //此mDevices和EventHub中的mDevices数据一一对应</span><br><span class="line">    mDevices.add(deviceId, device);</span><br><span class="line">&#125;</span><br><span class="line">//创建设备,并添加设备的相关InputMapper</span><br><span class="line">InputDevice* InputReader::createDeviceLocked(int32_t deviceId,..., uint32_t classes) &#123;</span><br><span class="line">    InputDevice* device = new InputDevice(&amp;mContext, deviceId,..., classes);</span><br><span class="line">    //根据classes添加各种InputMapper</span><br><span class="line">    // Touchscreens and touchpad devices.</span><br><span class="line">    if (classes &amp; INPUT_DEVICE_CLASS_TOUCH_MT) &#123;</span><br><span class="line">        device-&gt;addMapper(new MultiTouchInputMapper(device));</span><br><span class="line">    &#125; else if (classes &amp; INPUT_DEVICE_CLASS_TOUCH) &#123;</span><br><span class="line">        device-&gt;addMapper(new SingleTouchInputMapper(device));</span><br><span class="line">    &#125;</span><br><span class="line">    return device;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新设备配置-InputMapper"><a href="#新设备配置-InputMapper" class="headerlink" title="新设备配置 InputMapper"></a>新设备配置 InputMapper</h3><p>InputMapper 用于对原始数据的加工</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void InputReader::addDeviceLocked(nsecs_t when, int32_t deviceId) &#123;</span><br><span class="line">    ssize_t deviceIndex = mDevices.indexOfKey(deviceId);</span><br><span class="line">    InputDevice* device = createDeviceLocked(deviceId, controllerNumber, identifier, classes);</span><br><span class="line">    //配置设备的InputMapper</span><br><span class="line">    device-&gt;configure(when, &amp;mConfig, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InputDevice::configure(nsecs_t when, const InputReaderConfiguration* config, uint32_t changes) &#123;</span><br><span class="line">    for (size_t i = 0; i &lt; numMappers; i++) &#123;</span><br><span class="line">        InputMapper* mapper = mMappers[i];</span><br><span class="line">        mapper-&gt;configure(when, config, changes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//以TouchInputMapper为例</span><br><span class="line">void TouchInputMapper::configure(nsecs_t when,</span><br><span class="line">        const InputReaderConfiguration* config, uint32_t changes) &#123;</span><br><span class="line">    InputMapper::configure(when, config, changes);</span><br><span class="line">    mConfig = *config;</span><br><span class="line">    configureSurface(when, &amp;resetNeeded);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TouchInputMapper::configureSurface(nsecs_t when, bool* outResetNeeded) &#123;</span><br><span class="line">    DisplayViewport newViewport;</span><br><span class="line">    mConfig.getDisplayInfo(mParameters.associatedDisplayIsExternal, &amp;newViewport)</span><br><span class="line">    mViewport = newViewport;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="InputReader中-mConfig-获取显示屏信息"><a href="#InputReader中-mConfig-获取显示屏信息" class="headerlink" title="InputReader中 mConfig 获取显示屏信息"></a>InputReader中 mConfig 获取显示屏信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void InputReader::refreshConfigurationLocked(uint32_t changes) &#123;</span><br><span class="line">    //将显示屏信息保存到mConfig中</span><br><span class="line">    mPolicy-&gt;getReaderConfiguration(&amp;mConfig);</span><br><span class="line">&#125;</span><br><span class="line">void NativeInputManager::getReaderConfiguration(InputReaderConfiguration* outConfig) &#123;</span><br><span class="line">        outConfig-&gt;setDisplayInfo(false /*external*/, mLocked.internalViewport);</span><br><span class="line">        outConfig-&gt;setDisplayInfo(true /*external*/, mLocked.externalViewport);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>显示屏信息从 DisplayManagerService 下发到 NativeInputManager 驱动层<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//DisplayManagerService.java</span><br><span class="line">mInputManagerInternal.setDisplayViewports(...)</span><br><span class="line"></span><br><span class="line">//InputManagerService.java</span><br><span class="line">LocalService#setDisplayViewports(DisplayViewport defaultView...)&#123;</span><br><span class="line">    setDisplayViewportsInternal(defaultViewport, exte..)</span><br><span class="line">&#125;</span><br><span class="line">void setDisplayViewportsInternal(DisplayViewport defaultViewport...)&#123;</span><br><span class="line">    setDisplayViewport(false,..)</span><br><span class="line">&#125;</span><br><span class="line">private void setDisplayViewport(boolean external, DisplayViewport viewport) &#123;</span><br><span class="line">    nativeSetDisplayViewport(mPtr, external,...)</span><br><span class="line">&#125;</span><br><span class="line">//com_android_server_input_InputManagerService.cpp</span><br><span class="line">static void nativeSetDisplayViewport(JNIEnv* /* env */, )&#123;</span><br><span class="line">        im-&gt;setDisplayViewport(external, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void NativeInputManager::setDisplayViewport(bool external, const DisplayViewport&amp; viewport) &#123;</span><br><span class="line">    DisplayViewport&amp; v = external ? mLocked.externalViewport : mLocked.internalViewport;</span><br><span class="line">    //将Framework层传递下来的信息保存在mLocked结构体中</span><br><span class="line">    v = viewport;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="Touch-触摸触屏事件处理"><a href="#Touch-触摸触屏事件处理" class="headerlink" title="Touch 触摸触屏事件处理"></a>Touch 触摸触屏事件处理</h2><h3 id="InputReader-事件读取以及对事件的加工"><a href="#InputReader-事件读取以及对事件的加工" class="headerlink" title="InputReader 事件读取以及对事件的加工"></a>InputReader 事件读取以及对事件的加工</h3><ul><li>InputReader::loopOnce()<ul><li>mEventHub-&gt;getEvents(timeoutMi..)从 dev/input/ 下读取事件</li><li>processEventsLocked(mEventBuffer, count); 处理事件</li><li>mQueuedListener-&gt;flush(); 通知 Dispatcher 分发事件</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">void InputReader::loopOnce()&#123;</span><br><span class="line">    size_t count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);</span><br><span class="line">    processEventsLocked(mEventBuffer, count);</span><br><span class="line">    mQueuedListener-&gt;flush();</span><br><span class="line">&#125;</span><br><span class="line">void InputReader::processEventsLocked(const RawEvent* rawEvents, size_t count) &#123;</span><br><span class="line">    for (const RawEvent* rawEvent = rawEvents; count;) &#123;</span><br><span class="line">        int32_t deviceId = rawEvent-&gt;deviceId;</span><br><span class="line">        //batchSize 表示从当前rawEvent 后面还有多少个是该设备的事件</span><br><span class="line">        //将连续的相同设备的事件一起处理</span><br><span class="line">        processEventsForDeviceLocked(deviceId, rawEvent, batchSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void InputReader::processEventsForDeviceLocked(int32_t deviceId,...)&#123;</span><br><span class="line">    //获取到产生事件的设备对象</span><br><span class="line">    InputDevice* device = mDevices.valueAt(deviceIndex);</span><br><span class="line">    device-&gt;process(rawEvents, count);</span><br><span class="line">&#125;</span><br><span class="line">void InputDevice::process(const RawEvent* rawEvents, size_t count) &#123;</span><br><span class="line">    for (const RawEvent* rawEvent = rawEvents; count--; rawEvent++) &#123;</span><br><span class="line">        for (size_t i = 0; i &lt; numMappers; i++) &#123;</span><br><span class="line">            InputMapper* mapper = mMappers[i];</span><br><span class="line">            mapper-&gt;process(rawEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//多点触控</span><br><span class="line">void MultiTouchInputMapper::process(const RawEvent* rawEvent) &#123;</span><br><span class="line">    //Step 1</span><br><span class="line">    TouchInputMapper::process(rawEvent);</span><br><span class="line">    //Step 2</span><br><span class="line">    mMultiTouchMotionAccumulator.process(rawEvent);</span><br><span class="line">&#125;</span><br><span class="line">void TouchInputMapper::process(const RawEvent* rawEvent) &#123;</span><br><span class="line">    //一个完成的事件接收完</span><br><span class="line">    if (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_REPORT) &#123;</span><br><span class="line">        sync(rawEvent-&gt;when);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//将当前数据保存到mRawStatesPending队列中</span><br><span class="line">void TouchInputMapper::sync(nsecs_t when) &#123;</span><br><span class="line">    mRawStatesPending.push();</span><br><span class="line">    RawState* next = &amp;mRawStatesPending.editTop();</span><br><span class="line">    next-&gt;buttonState = mTouchButtonAccumulator.getButtonState()</span><br><span class="line">            | mCursorButtonAccumulator.getButtonState();</span><br><span class="line">    // Sync scroll</span><br><span class="line">    next-&gt;rawVScroll = mCursorScrollAccumulator.getRelativeVWheel();</span><br><span class="line">    next-&gt;rawHScroll = mCursorScrollAccumulator.getRelativeHWheel();</span><br><span class="line">    mCursorScrollAccumulator.finishSync();</span><br><span class="line">    // Sync touch</span><br><span class="line">    //填充next-&gt;rawPointerData.pointers[],将x,y,pressure等数据填充完</span><br><span class="line">    syncTouch(when, next);</span><br><span class="line">    processRawTouches(false /*timeout*/);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TouchInputMapper::processRawTouches(bool timeout) &#123;</span><br><span class="line">    const size_t N = mRawStatesPending.size();</span><br><span class="line">    size_t count;</span><br><span class="line">    for(count = 0; count &lt; N; count++) &#123;</span><br><span class="line">        const RawState&amp; next = mRawStatesPending[count];</span><br><span class="line">        mCurrentRawState.copyFrom(next);</span><br><span class="line">        cookAndDispatch(mCurrentRawState.when);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TouchInputMapper::cookAndDispatch(nsecs_t when) &#123;</span><br><span class="line">    cookPointerData();</span><br><span class="line">    dispatchTouches(when, policyFlags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TouchInputMapper::cookPointerData() &#123;</span><br><span class="line">    //同时有多少个触点</span><br><span class="line">    uint32_t currentPointerCount = mCurrentRawState.rawPointerData.pointerCount;</span><br><span class="line">    for (uint32_t i = 0; i &lt; currentPointerCount; i++) &#123;</span><br><span class="line">        const RawPointerData::Pointer&amp; in = mCurrentRawState.rawPointerData.pointers[i];</span><br><span class="line">        //将原始数据in处理完保存到该队列</span><br><span class="line">        PointerCoords&amp; out = mCurrentCookedState.cookedPointerData.pointerCoords[i];</span><br><span class="line">        out.clear();</span><br><span class="line">        out.setAxisValue(AMOTION_EVENT_AXIS_X, x);</span><br><span class="line">        mCurrentCookedState.cookedPointerData.idToIndex[id] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TouchInputMapper::dispatchTouches(nsecs_t when, uint32_t policyFlags) &#123;</span><br><span class="line">    dispatchMotion(when, policyFlags, mSource,...);</span><br><span class="line">&#125;</span><br><span class="line">void TouchInputMapper::dispatchMotion(nsecs_t when, uint32...)&#123;</span><br><span class="line">    NotifyMotionArgs args(when, getDeviceId(), source, ...);</span><br><span class="line">    getListener()-&gt;notifyMotion(&amp;args);</span><br><span class="line">&#125;</span><br><span class="line">InputListenerInterface* InputReader::ContextImpl::getListener() &#123;</span><br><span class="line">    return mReader-&gt;mQueuedListener.get();</span><br><span class="line">&#125;</span><br><span class="line">//保存到队列中</span><br><span class="line">void QueuedInputListener::notifyMotion(const NotifyMotionArgs* args) &#123;</span><br><span class="line">    mArgsQueue.push(new NotifyMotionArgs(*args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="InputReader-唤醒-InputDispatcher-线程"><a href="#InputReader-唤醒-InputDispatcher-线程" class="headerlink" title="InputReader 唤醒 InputDispatcher  线程"></a>InputReader 唤醒 InputDispatcher  线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//开始通知dispatcher线程分发消息</span><br><span class="line">void QueuedInputListener::flush() &#123;</span><br><span class="line">    size_t count = mArgsQueue.size();</span><br><span class="line">    for (size_t i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        NotifyArgs* args = mArgsQueue[i];</span><br><span class="line">        args-&gt;notify(mInnerListener);</span><br><span class="line">        delete args;</span><br><span class="line">    &#125;</span><br><span class="line">    mArgsQueue.clear();</span><br><span class="line">&#125;</span><br><span class="line">void NotifyMotionArgs::notify(const sp&lt;InputListenerInterface&gt;&amp; listener) const &#123;</span><br><span class="line">    listener-&gt;notifyMotion(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InputDispatcher::notifyMotion(const NotifyMotionArgs* args)&#123;</span><br><span class="line">    // Just enqueue a new motion event.</span><br><span class="line">    MotionEntry* newEntry = new MotionEntry(args-&gt;eventTime,...);</span><br><span class="line">    needWake = enqueueInboundEventLocked(newEntry);</span><br><span class="line">    if (needWake) &#123;</span><br><span class="line">        //唤醒InputDispatcherThread</span><br><span class="line">        mLooper-&gt;wake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//触屏事件保存mInboundQueue</span><br><span class="line">bool InputDispatcher::enqueueInboundEventLocked(EventEntry* entry) &#123;</span><br><span class="line">    bool needWake = mInboundQueue.isEmpty();</span><br><span class="line">    mInboundQueue.enqueueAtTail(entry);</span><br><span class="line">    case EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">        MotionEntry* motionEntry = static_cast&lt;MotionEntry*&gt;(entry);</span><br><span class="line">        if (motionEntry-&gt;action == AMOTION_EVENT_ACTION_DOWN...) &#123;</span><br><span class="line">            sp&lt;InputWindowHandle&gt; touchedWindowHandle = findTouchedWindowAtLocked(displayId, x, y);</span><br><span class="line">            if (touchedWindowHandle != NULL,,,) &#123;</span><br><span class="line">                mNextUnblockedEvent = motionEntry;</span><br><span class="line">                needWake = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return needWake;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="InputDispatcher-分发事件"><a href="#InputDispatcher-分发事件" class="headerlink" title="InputDispatcher 分发事件"></a>InputDispatcher 分发事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void InputDispatcher::dispatchOnce() &#123;</span><br><span class="line">        if (!haveCommandsLocked()) &#123;</span><br><span class="line">            dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">void InputDispatcher::dispatchOnceInnerLocked(nsecs_t* nextWakeupTime) &#123;</span><br><span class="line">            mPendingEvent = mInboundQueue.dequeueAtHead();</span><br><span class="line">    case EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">        MotionEntry* typedEntry = static_cast&lt;MotionEntry*&gt;(mPendingEvent);</span><br><span class="line">        done = dispatchMotionLocked(currentTime, typedEntry,...);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool InputDispatcher::dispatchMotionLocked(nsecs_t currentTime, MotionE)&#123;</span><br><span class="line">    // Identify targets.</span><br><span class="line">    Vector&lt;InputTarget&gt; inputTargets;</span><br><span class="line">        // Pointer event.  (eg. touchscreen)</span><br><span class="line">        injectionResult = findTouchedWindowTargetsLocked(currentTime,</span><br><span class="line">                entry, inputTargets, nextWakeupTime, &amp;conflictingPointerActions);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="部分函数备忘"><a href="#部分函数备忘" class="headerlink" title="部分函数备忘"></a>部分函数备忘</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">InputDispatcher::findTouchedWindowTargetsLocked()&#123;</span><br><span class="line">        size_t numWindows = mWindowHandles.size();</span><br><span class="line">        for (size_t i = 0; i &lt; numWindows; i++) &#123;</span><br><span class="line">            sp&lt;InputWindowHandle&gt; windowHandle = mWindowHandles.itemAt(i);</span><br><span class="line">            const InputWindowInfo* windowInfo = windowHandle-&gt;getInfo();</span><br><span class="line">            //窗口判断</span><br><span class="line">            if (windowInfo-&gt;displayId != displayId) &#123;</span><br><span class="line">                continue; // wrong display</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">cookPointerData()函数物理坐标转换成屏幕坐标</span><br><span class="line">为事件寻找窗口分为普通窗口以及监听窗口,普通窗口按查找与焦点获取,监听窗口则无条件监听所有输入.</span><br><span class="line">卷3中5.3.3 DispatcherPolicy mPolicy,此接口实现位于JNI层NativeInputManager,他会将请求转交给Java层的IMS进行处理,期中interceptMotionBeforeQueueing()等最终会由IMS转交给WMS的InputMonitor,而InputMonitor再转交给PhoneWindowManager处理.</span><br><span class="line">截屏:interceptKeyBeforQueueing() 音量下+电源键</span><br></pre></td></tr></table></figure><hr><h2 id="Java-层事件接收"><a href="#Java-层事件接收" class="headerlink" title="Java 层事件接收"></a>Java 层事件接收</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">android.view.ViewRootImpl#setView(View view, WindowMan...)&#123;</span><br><span class="line">                    mInputChannel = new InputChannel();</span><br><span class="line">                    //最终调用到WindowManagerService#addWindow</span><br><span class="line">                    res = mWindowSession.addToDisplay(mWindow,...mInputChannel);</span><br><span class="line">                if (mInputChannel != null) &#123;</span><br><span class="line">                    if (mInputQueueCallback != null) &#123;</span><br><span class="line">                        mInputQueue = new InputQueue();</span><br><span class="line">                        mInputQueueCallback.onInputQueueCreated(mInputQueue);</span><br><span class="line">                    &#125;</span><br><span class="line">                    //接收到底层传递过来的事件,关联mView进行事件分发</span><br><span class="line">                    mInputEventReceiver = new WindowInputEventReceiver(mInputChannel,</span><br><span class="line">                            Looper.myLooper());</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line">com.android.server.wm.WindowManagerService#addWindow(Session session, ...,InputChannel outInputChannel)&#123;</span><br><span class="line">            if (outInputChannel != null ...) &#123;</span><br><span class="line">                String name = win.makeInputChannelName();</span><br><span class="line">                InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);</span><br><span class="line">                win.setInputChannel(inputChannels[0]);</span><br><span class="line">                //关联上传递进来的 outInputChannel</span><br><span class="line">                inputChannels[1].transferTo(outInputChannel);</span><br><span class="line">                //注册到native,最终会调用到 InputDispatcher::registerInputChannel</span><br><span class="line">                mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">status_t InputDispatcher::registerInputChannel(const sp&lt;InputChannel&gt;&amp; inputChannel,..)&#123;</span><br><span class="line">        sp&lt;Connection&gt; connection = new Connection(inputChannel, inputWindowHandle, monitor);</span><br><span class="line">        int fd = inputChannel-&gt;getFd();</span><br><span class="line">        mConnectionsByFd.add(fd, connection);</span><br><span class="line">        if (monitor) &#123;</span><br><span class="line">            mMonitoringChannels.push(inputChannel);</span><br><span class="line">        &#125;</span><br><span class="line">        mLooper-&gt;addFd(fd, 0, ALOOPER_EVENT_INPUT, handleReceiveCallback, this);</span><br><span class="line">&#125;</span><br><span class="line">//WindowInputEventReceiver对于touch事件最终分发函数</span><br><span class="line">//事件分发给view</span><br><span class="line">private int ViewPostImeInputStage::processPointerEvent(QueuedInputEvent q) &#123;</span><br><span class="line">    final MotionEvent event = (MotionEvent)q.mEvent;</span><br><span class="line">    mAttachInfo.mUnbufferedDispatchRequested = false;</span><br><span class="line">    //此处的 mView 则是在 setView(View view,...) 函数传递进来的</span><br><span class="line">    boolean handled = mView.dispatchPointerEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shouldDropInputEvent()窗口焦点判断</p><p>多窗口<br>//焦点获取监听设置<br>DisplayContent newDisplayContentLocked(final Display display)</p><p>//配置屏幕大小<br>void TouchInputMapper::configureSurface</p><p>//主显示器<br>static bool InputDispatcher::isMainDisplay(int32_t displayId)</p><p>//显示器状态更新<br>class DisplayManagerHandler<br>//新增显示屏<br>private void addLogicalDisplayLocked(DisplayDevice device) {<br>    LogicalDisplay display = new LogicalDisplay(displayId, layerStack, device);<br>    display.updateLocked(mDisplayDevices);<br>    mLogicalDisplays.put(displayId, display);<br>    sendDisplayEventLocked(displayId, DisplayManagerGlobal.EVENT_DISPLAY_ADDED);<br>}<br>DisplayAdapterListener //设备新增,删除状态监听<br>DisplayDevice 代表一个物理设备<br>//配置默认显示屏参数<br>void configureDisplayInTransactionLocked(DisplayDevice device)<br>//副屏display.hasContentLocked()=true<br>if (display != null &amp;&amp; !display.hasContentLocked()) {<br>//显示屏属性设置<br>mDisplayManagerInternal.setDisplayProperties(displayId,<br>void handleNotObscuredLocked(final WindowState w,..){<br>    if (displayContent != null &amp;&amp; displayContent.isDefaultDisplay) {<br>        mInnerFields.mDisplayHasContent = true;<br>    }<br>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;ActivityManagerService&quot;&gt;&lt;a href=&quot;#ActivityManagerService&quot; class=&quot;headerlink&quot; title=&quot;ActivityManagerService&quot;&gt;&lt;/a&gt;Activit
      
    
    </summary>
    
    
      <category term="android 源码" scheme="https://github.com/luv135/luv135.github.io/blob/hexo/source/_posts/tags/android-%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin tips</title>
    <link href="https://github.com/luv135/luv135.github.io/blob/hexo/source/_posts/2018/11/04/kotlin%20tips/"/>
    <id>https://github.com/luv135/luv135.github.io/blob/hexo/source/_posts/2018/11/04/kotlin tips/</id>
    <published>2018-11-04T15:16:33.789Z</published>
    <updated>2018-11-06T15:07:18.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="扩展函数-泛型使用"><a href="#扩展函数-泛型使用" class="headerlink" title="扩展函数/泛型使用"></a>扩展函数/泛型使用</h1><p>对于TextView, Button, 调用该函数,直接返回该函数对象,不需要在转换<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T : View&gt; T.addToLayout(): T &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;扩展函数-泛型使用&quot;&gt;&lt;a href=&quot;#扩展函数-泛型使用&quot; class=&quot;headerlink&quot; title=&quot;扩展函数/泛型使用&quot;&gt;&lt;/a&gt;扩展函数/泛型使用&lt;/h1&gt;&lt;p&gt;对于TextView, Button, 调用该函数,直接返回该函数对象,不需要在
      
    
    </summary>
    
    
      <category term="kotlin" scheme="https://github.com/luv135/luv135.github.io/blob/hexo/source/_posts/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>git 命令</title>
    <link href="https://github.com/luv135/luv135.github.io/blob/hexo/source/_posts/2018/11/04/git%20usage/"/>
    <id>https://github.com/luv135/luv135.github.io/blob/hexo/source/_posts/2018/11/04/git usage/</id>
    <published>2018-11-04T15:16:33.788Z</published>
    <updated>2018-11-06T15:11:05.108Z</updated>
    
    <content type="html"><![CDATA[<p>以下示例远程仓库的默认名称是<code>origin</code></p><h1 id="仓库交互"><a href="#仓库交互" class="headerlink" title="仓库交互"></a>仓库交互</h1><ul><li>将目录初始化为git 仓库: <code>git init</code></li><li><p>关远程地仓库: <code>git remote add origin https://github.com/luv135/luv135.github.io.git</code></p></li><li><p>推送分支: <code>git push &lt;远程主机名&gt; &lt;本地分支&gt;:&lt;远程分支名&gt;</code><br><br>如: <code>git push origin master:master</code></p></li><li>删除远程关联仓库<code>git remote rm origin</code></li><li>删除远程分支: <code>git push --delete origin 分支名</code></li><li><p>查看远程库信息，使用<code>git remote -v</code></p></li><li><p>拉取远程分支: <code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></p></li><li><p>拉取分支: <code>git fetch</code> 该命令将远程分支拉取到本地,但不合并</p></li><li><p>rebase 分支: <code>git rebase -i</code> 合并分支,对于历史提交的进行修改</p></li></ul><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><ul><li><p>查看分支: <code>git branch</code></p></li><li><p>查看远程分支: <code>git branch -r</code></p></li><li><p>查看所有分支: <code>git branch -a</code></p></li><li><p>创建分支: <code>git branch &lt;name&gt;</code></p></li><li><p>本地分支和远程分支关联: <code>git checkout -b 本地分支 origin/远程分支</code></p></li><li><p>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream 本地分支 origin/远程分支</code></p></li></ul><ul><li><p>切换分支: <code>git checkout &lt;name&gt;</code></p></li><li><p>创建+切换分支: <code>git checkout -b &lt;name&gt;</code></p></li><li><p>合并某分支到当前分支: <code>git merge &lt;name&gt;</code></p></li><li><p>删除分支: <code>git branch -d &lt;name&gt;</code></p></li><li><p>重置分支: <code>git reset</code></p></li><li><p>强行删除: <code>git branch -D &lt;name&gt;</code></p></li><li><p>取回所有分支: <code>git fetch &lt;远程主机名&gt;</code></p></li><li><p>取回特定分支: <code>git fetch &lt;远程主机名&gt; &lt;分支名&gt;</code></p></li><li><p>忽略的文件: <code>.gitignore</code></p></li><li><p>分支合并图: <code>git log --graph</code></p></li><li><p>合并分支并生产一个commit: <code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code></p></li><li><p>重命名分支: <code>git branch -m &lt;oldname&gt; &lt;newname&gt;</code> 当前分支则:<code>git branch -m &lt;newname&gt;</code></p></li></ul><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><ul><li><p>刪除文件: <code>git rm test.txt</code></p></li><li><p>撤銷刪除: <code>git checkout -- test.txt</code></p></li><li><p>文件撤出暫存區: <code>git reset HEAD readme.txt</code></p></li><li><p>丟棄工作區修改: <code>git checkout -- readme.txt</code></p></li><li><p>已经提交的commit, 从一个分支放到另一个分支: <code>git cherry-pick &lt;commit id&gt;</code></p></li><li><p>git查看各个branch之间的关系图: <code>git log --graph --decorate --oneline --simplify-by-decoration --all</code></p></li><li><p>回滚单个文件到某历史提交: <code>git reset commit_id 文件路径</code></p></li><li><p>查看单个文件历史提交: <code>git log --pretty=oneline 文件名</code></p></li><li><p>查看文件两个commit的区别: <code>git diff commit_id_1 commit_id_2 -- 文件路径</code></p></li></ul><h1 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h1><ul><li>添加子模块: <code>git submodule add 地址 本地路径(可选)</code></li><li>克隆子模块: <code>cd 模块文件夹 git submodule init git submodule update</code> </li></ul><p>参考:<br><a href="http://www.liaoxuefeng.com/" target="_blank" rel="noopener">http://www.liaoxuefeng.com/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下示例远程仓库的默认名称是&lt;code&gt;origin&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;仓库交互&quot;&gt;&lt;a href=&quot;#仓库交互&quot; class=&quot;headerlink&quot; title=&quot;仓库交互&quot;&gt;&lt;/a&gt;仓库交互&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;将目录初始化为git 仓库: 
      
    
    </summary>
    
    
      <category term="git" scheme="https://github.com/luv135/luv135.github.io/blob/hexo/source/_posts/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://github.com/luv135/luv135.github.io/blob/hexo/source/_posts/2018/10/15/hello-world/"/>
    <id>https://github.com/luv135/luv135.github.io/blob/hexo/source/_posts/2018/10/15/hello-world/</id>
    <published>2018-10-15T14:17:37.264Z</published>
    <updated>2018-10-15T14:17:37.265Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
